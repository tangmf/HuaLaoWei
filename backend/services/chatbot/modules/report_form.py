"""
report_form.py

A customised user experience workflow for the HuaLaoWei municipal chatbot.
Handles user input during issue reporting, manages step-by-step form flow, 
and enriches information using a Vision-Language Model (VLM).

Author: Fleming Siow
Date: 3rd May 2025
"""

# --------------------------------------------------------
# Imports
# --------------------------------------------------------

import logging
import uuid
from config.config import config
from mobile_app.backend.services.vlm_issue_categoriser.service import VLMIssueCategoriserPipeline
from mobile_app.backend.crud import posts as crud_posts
from mobile_app.backend.crud import issues as crud_issues
from mobile_app.backend.crud import authorities as crud_authorities
from mobile_app.backend.crud import regions as crud_regions
from mobile_app.backend.crud import media as crud_media

# --------------------------------------------------------
# Logger Setup
# --------------------------------------------------------

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --------------------------------------------------------
# VLM Issue Categoriser Pipeline Setup
# --------------------------------------------------------

vlm_pipeline = VLMIssueCategoriserPipeline()
vlm_pipeline.setup()

# --------------------------------------------------------
# Form Manager
# --------------------------------------------------------

class ReportFormManager:
    """
    ReportFormManager manages the multi-step form interaction process for filing a municipal issue report.
    """
    def __init__(self):
        self.active = False
        self.session_id = None
        self.user_id = None
        self.fields = {
            "title": None,           # Generated by ??
            "description": None,
            "address": None,
            "latitude": None,
            "longitude": None,
            "severity": None,        # Generated by VLM
            "categories": [],        # Generated by VLM
            "issue_type_ids": [],
            "issue_subtype_ids": [],
            "images": [],
            "agency_id": None,
            "town_council_id": None,
            "planning_area_id": None,
            "subzone_id": None
        }
        self.steps = ["description", "address", "image"]
        self.current_step = 0
        self.awaiting_image = False
        self.awaiting_change_field = None

    # --------------------------------------------------------
    # Public Methods
    # --------------------------------------------------------

    def start(self, session_id: str = None, user_id: str = None) -> None:
        """
        Start a new form session.

        Args:
            session_id (str, optional): Provided session ID.
            user_id (str, optional): Provided user ID.
        """
        self.active = True
        self.session_id = session_id or str(uuid.uuid4())
        self.user_id = user_id
        self.current_step = 0
        self.awaiting_image = False

    async def reset(self) -> None:
        """
        Reset the form to initial state.
        """
        self.__init__()

    async def receive_input(self, input_text: str, input_images: list = None) -> str:
        """
        Process user input and advance the form state.

        Args:
            input_text (str): Text input from user.
            input_images (list, optional): List of image inputs.

        Returns:
            str: Status string ("updated", "next").
        """
        if self.awaiting_change_field:
            self.fields[self.awaiting_change_field] = input_text
            self.awaiting_change_field = None
            return "updated"

        if self.awaiting_image:
            if input_images:
                for image in input_images:
                    self.fields["images"].append(image)

                predictions = await vlm_pipeline.run({"text": input_text, "locaation": { }, "images": input_images})

                self.fields["severity"] = predictions.get("severity")

                self.fields["categories"] = predictions.get("categories", [])
                self.fields["issue_subtype_ids"] = [crud_issues.fetch_issue_subtype_info_from_name(i)["issue_subtype_id"] for i in self.fields["categories"]]
                self.fields["issue_type_ids"] = list(set(crud_issues.fetch_issue_subtype(i)["issue_type_id"] for i in self.fields["issue_subtype_ids"]))

                self.fields["title"] = predictions.get("title") or None

                self.fields["agency_id"] = crud_authorities.fetch_agency_id_from_name(predictions.get("agency")) or None
                self.fields["town_council_id"] = crud_authorities.fetch_town_council_id_from_name(predictions.get("town_council")) or None
                
            self.awaiting_image = False
            self.current_step += 1
            return "next"

        if self.current_step < len(self.steps):
            field = self.steps[self.current_step]

            if field == "description":
                self.fields["description"] = input_text
            elif field == "address":
                self.fields["address"] = input_text

            self.current_step += 1
            return "next"

        return "completed"

    async def is_complete(self) -> bool:
        """
        Check whether the form has completed all steps.

        Returns:
            bool: True if complete, False otherwise.
        """
        return self.current_step >= len(self.steps)

    async def next_question(self) -> str:
        """
        Get the next question to ask the user based on the current step.

        Returns:
            str: Prompt for the next step or None if completed.
        """
        if self.current_step == 0:
            return "Sure! Can you describe what the issue is about?"
        elif self.current_step == 1:
            return "Where is the issue located?"
        elif self.current_step == 2:
            self.awaiting_image = True
            return "Do you have any images of the issue to provide me?"
        else:
            return None

    async def generate_summary(self) -> str:
        """
        Generate a summary of the collected form fields.

        Returns:
            str: Formatted string summary.
        """
        parts = [
            f"- Title: {self.fields['title']}",
            f"- Description: {self.fields['description']}",
            f"- Address: {self.fields['address']}",
            f"- Severity: {self.fields['severity']}",
            f"- Categories: {', '.join(self.fields['categories'])}"
        ]
        return "\n".join(parts)

    async def start_change_field(self, field_name: str) -> bool:
        """
        Initiate a field correction step.

        Args:
            field_name (str): Name of the field to change.

        Returns:
            bool: True if field is valid, False otherwise.
        """
        if field_name in self.fields:
            self.awaiting_change_field = field_name
            return True
        return False

    async def cancel(self) -> None:
        """
        Cancel and reset the form process.
        """
        await self.reset()

    async def finalise_submission(self, resources) -> dict:
        """
        Finalize the collected report and reset the form.

        Returns:
            dict: Report submission payload.
        """
        await self._save_to_db(resources)
        report_submission = {
            "session_id": self.session_id,
            "user_id": self.user_id,
            "issue_data": self.fields,
        }
        await self.reset()
        return report_submission
    
    # --------------------------------------------------------
    # Internal Methods
    # --------------------------------------------------------

    async def _save_to_db(self, resources) -> None:

        # Determine planning area and subzone from lat, lng
        region = crud_regions.fetch_region_from_lat_lng(lat=self.fields["latitude"], lng=self.fields["longitude"])
        self.fields["planning_area_id"] = region.planning_area_id
        self.fields["subzone_id"] = region.subzone_id

        # Make a copy of the user's submission in case
        payload = self.fields.copy()

        try:
           issue_id = crud_issues.create_issue(resources=resources, issue=payload).issue_id

           if payload.get("images"):
                
                image_urls = []
                for image in payload["images"]:
                    # Upload image to storage and retrieve url
                    image_url = crud_media.upload_file_to_os(resources=resources, bucket_name="hualaowei", object_name=f"/reports/{str(uuid.uuid4())}.jpg", image_data=image)
                    image_urls.append(image_url)

                    # Map the image to the corresponding issue in db
                    await crud_media.map_media_to_issue(resources=resources, issue_id=issue_id, media_type="image", file_path=image_url)
                    
        except Exception as e:
            logger.error(f"Failed to save issue report to data stores: {str(e)}")