"""
report_form.py

A customised user experience workflow for the HuaLaoWei municipal chatbot.
Handles user input during issue reporting, manages step-by-step form flow, 
and enriches information using a Vision-Language Model (VLM).

Author: Fleming Siow
Date: 3rd May 2025
"""

# --------------------------------------------------------
# Imports
# --------------------------------------------------------

import io 
import logging
import uuid
import psycopg2
from services.vlm_issue_categoriser.pipeline import VLMIssueCategoriserPipeline
from config.config import config
from mobile_app.backend.crud import posts as crud_posts
from mobile_app.backend.crud import issues as crud_issues
from mobile_app.backend.crud import authorities as crud_authorities
from mobile_app.backend.crud import regions as crud_regions

# --------------------------------------------------------
# Logger Setup
# --------------------------------------------------------

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --------------------------------------------------------
# Object Storage Setup
# --------------------------------------------------------

if config.env == "dev":
    from minio import Minio

    try:
        os_config = config.data_stores.object_storage
        os_endpoint = os_config.endpoint
        os_access_key = os_config.access_key
        os_secret_key = os_config.secret_key
        os_bucket_name = os_config.bucket_name
        os_url = os_config.url
    except AttributeError:
        raise ValueError("Object storage configurations missing in config")

    os_client = Minio(
        os_endpoint,
        access_key=os_access_key,
        secret_key=os_secret_key,
        secure=False
    )

    if not os_client.bucket_exists(os_bucket_name):
        os_client.make_bucket(os_bucket_name)

# --------------------------------------------------------
# Relational Database Setup
# --------------------------------------------------------
try:
    db_config = config.data_stores.relational_db
    db_host = db_config.host
    db_port = db_config.port
    db_database = db_config.database
    db_user = db_config.user
    db_password = db_config.password
    # db_ssl = db_config.ssl
except AttributeError:
    raise ValueError("Relational Database configurations missing in config")

try:
    conn = psycopg2.connect(
        host=db_host,
        port=db_port,
        database=db_database,
        user=db_user,
        password=db_password,
        # sslmode="require" if db_ssl else "disable"
    )
    conn.autocommit = True
except Exception as e:
    logger.error(f"Failed to connect to PostgreSQL: {str(e)}")
    raise
logger.info(f"Connected to PostgreSQL at {db_host}:{db_port}")

# --------------------------------------------------------
# VLM Issue Categoriser Pipeline Setup
# --------------------------------------------------------

vlm_pipeline = VLMIssueCategoriserPipeline()
vlm_pipeline.setup()

# --------------------------------------------------------
# Form Manager
# --------------------------------------------------------

class ReportFormManager:
    """
    ReportFormManager manages the multi-step form interaction process for filing a municipal issue report.
    """
    def __init__(self):
        self.active = False
        self.session_id = None
        self.user_id = None
        self.fields = {
            "title": None,           # Generated by ??
            "description": None,
            "address": None,
            "latitude": None,
            "longitude": None,
            "severity": None,        # Generated by VLM
            "categories": [],        # Generated by VLM
            "issue_type_ids": [],
            "issue_subtype_ids": [],
            "images": [],
            "agency_id": None,
            "town_council_id": None,
            "planning_area_id": None,
            "subzone_id": None
        }
        self.steps = ["description", "address", "image"]
        self.current_step = 0
        self.awaiting_image = False
        self.awaiting_change_field = None

    # --------------------------------------------------------
    # Public Methods
    # --------------------------------------------------------

    def start(self, session_id: str = None, user_id: str = None) -> None:
        """
        Start a new form session.

        Args:
            session_id (str, optional): Provided session ID.
            user_id (str, optional): Provided user ID.
        """
        self.active = True
        self.session_id = session_id or str(uuid.uuid4())
        self.user_id = user_id
        self.current_step = 0
        self.awaiting_image = False

    async def reset(self) -> None:
        """
        Reset the form to initial state.
        """
        self.__init__()

    async def receive_input(self, input_text: str, input_images: list = None) -> str:
        """
        Process user input and advance the form state.

        Args:
            input_text (str): Text input from user.
            input_images (list, optional): List of image inputs.

        Returns:
            str: Status string ("updated", "next").
        """
        if self.awaiting_change_field:
            self.fields[self.awaiting_change_field] = input_text
            self.awaiting_change_field = None
            return "updated"

        if self.awaiting_image:
            if input_images:
                for image in input_images:
                    self.fields["images"].append(image)

                predictions = await vlm_pipeline.run({"text": input_text, "locaation": { }, "images": input_images})

                self.fields["severity"] = predictions.get("severity")

                self.fields["categories"] = predictions.get("categories", [])
                self.fields["issue_subtype_ids"] = [crud_issues.fetch_issue_subtype_info_from_name(i)["issue_subtype_id"] for i in self.fields["categories"]]
                self.fields["issue_type_ids"] = list(set(crud_issues.fetch_issue_subtype(i)["issue_type_id"] for i in self.fields["issue_subtype_ids"]))

                self.fields["title"] = predictions.get("title") or None

                self.fields["agency_id"] = crud_authorities.fetch_agency_id_from_name(predictions.get("agency")) or None
                self.fields["town_council_id"] = crud_authorities.fetch_town_council_id_from_name(predictions.get("town_council")) or None
                
            self.awaiting_image = False
            self.current_step += 1
            return "next"

        if self.current_step < len(self.steps):
            field = self.steps[self.current_step]

            if field == "description":
                self.fields["description"] = input_text
            elif field == "address":
                self.fields["address"] = input_text

            self.current_step += 1
            return "next"

        return "completed"

    async def is_complete(self) -> bool:
        """
        Check whether the form has completed all steps.

        Returns:
            bool: True if complete, False otherwise.
        """
        return self.current_step >= len(self.steps)

    async def next_question(self) -> str:
        """
        Get the next question to ask the user based on the current step.

        Returns:
            str: Prompt for the next step or None if completed.
        """
        if self.current_step == 0:
            return "Sure! Can you describe what the issue is about?"
        elif self.current_step == 1:
            return "Where is the issue located?"
        elif self.current_step == 2:
            self.awaiting_image = True
            return "Do you have any images of the issue to provide me?"
        else:
            return None

    async def generate_summary(self) -> str:
        """
        Generate a summary of the collected form fields.

        Returns:
            str: Formatted string summary.
        """
        parts = [
            f"- Title: {self.fields['title']}",
            f"- Description: {self.fields['description']}",
            f"- Address: {self.fields['address']}",
            f"- Severity: {self.fields['severity']}",
            f"- Categories: {', '.join(self.fields['categories'])}"
        ]
        return "\n".join(parts)

    async def start_change_field(self, field_name: str) -> bool:
        """
        Initiate a field correction step.

        Args:
            field_name (str): Name of the field to change.

        Returns:
            bool: True if field is valid, False otherwise.
        """
        if field_name in self.fields:
            self.awaiting_change_field = field_name
            return True
        return False

    async def cancel(self) -> None:
        """
        Cancel and reset the form process.
        """
        await self.reset()

    async def finalise_submission(self) -> dict:
        """
        Finalize the collected report and reset the form.

        Returns:
            dict: Report submission payload.
        """
        await self._save_to_db()
        report_submission = {
            "session_id": self.session_id,
            "user_id": self.user_id,
            "issue_data": self.fields,
        }
        await self.reset()
        return report_submission
    
    # --------------------------------------------------------
    # Internal Methods
    # --------------------------------------------------------

    async def _upload_image_to_minio(self, image_data: bytes) -> str:
        object_name = f"reports/{uuid.uuid4()}.jpg"
        os_client.put_object(
            os_bucket_name,
            object_name,
            data=io.BytesIO(image_data),
            length=len(image_data),
            content_type="image/jpeg"
        )
        image_url = f"{os_url}/{os_bucket_name}/{object_name}"
        return image_url

    async def _save_to_db(self) -> None:
        region = crud_regions.fetch_region_from_lat_lng(lat=self.fields["latitude"], lng=self.fields["longitude"])
        self.fields["planning_area_id"] = region.planning_area_id
        self.fields["subzone_id"] = region.subzone_id

        payload = self.fields.copy()

        try:

            with conn.cursor() as cur:
                cur.execute(
                    """
                    INSERT INTO issues (
                        user_id, description, address, latitude, longitude,
                        severity, status, datetime_reported, datetime_updated, is_public
                    ) VALUES (
                        %s, %s, %s, %s, %s, %s, 'Reported', NOW(), NOW(), TRUE
                    )
                    RETURNING issue_id;
                    """,
                    (
                        self.user_id,
                        payload.get("description"),
                        payload.get("address"),
                        payload.get("latitude") or 0.0,
                        payload.get("longitude") or 0.0,
                        payload.get("severity")
                    )
                )

                issue_id = cur.fetchone()[0]

                if payload.get("images"):
                    for image in payload["images"]:
                        image_url = self._upload_image_to_minio(image)

                        cur.execute(
                            """
                            INSERT INTO issue_media_assets (
                                issue_id, media_type, file_path, metadata
                            ) VALUES (
                                %s, %s, %s, %s
                            )
                            """,
                            (
                                issue_id,
                                "image",
                                image_url,
                                None
                            )
                        )

                crud_posts.create_post(user_id=self.user_id, issue_id=issue_id)

            logger.info(f"Issue report {issue_id} inserted successfully.")

        except Exception as e:
            logger.error(f"Failed to save issue report to database: {str(e)}")